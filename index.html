<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<title>å¢å¼ºç‰ˆAIäº”å­æ£‹ (Python Backend)</title>
<style>
body { font-family: sans-serif; text-align: center; }
canvas { border:1px solid #333; margin-top:10px; cursor:pointer; display: block; margin-left: auto; margin-right: auto;}
#status { margin-top:10px; font-size: 1.2em; min-height: 1.5em; }
button { margin: 5px; padding: 8px 15px; font-size: 1em;}
.difficulty-selector { margin: 15px 0; }
.difficulty-selector label { margin: 0 10px; }
.thinking-indicator {
    display: none; /* Hidden by default */
    margin-left: 10px;
    font-style: italic;
    color: #555;
}
.thinking #status .thinking-indicator {
    display: inline; /* Show when thinking */
}
</style>
</head>
<body>
<h1>å¢å¼ºç‰ˆAIäº”å­æ£‹ (Python Backend)</h1>

<div class="difficulty-selector">
  <span>é€‰æ‹©éš¾åº¦:</span>
  <label><input type="radio" name="difficulty" value="2" onclick="setDifficulty(2)"> ç®€å•</label>
  <label><input type="radio" name="difficulty" value="3" checked onclick="setDifficulty(3)"> æ™®é€š (é»˜è®¤)</label>
  <label><input type="radio" name="difficulty" value="4" onclick="setDifficulty(4)"> å›°éš¾</label>
  <label><input type="radio" name="difficulty" value="5" onclick="setDifficulty(5)"> æéš¾ (å¯èƒ½è¾ƒæ…¢)</label>
  </div>

<canvas id="board" width="600" height="600"></canvas>
<div id="status">æ‚¨çš„å›åˆ<span class="thinking-indicator"> (AI æ€è€ƒä¸­...)</span></div>
<button onclick="resetGame()">é‡æ–°å¼€å§‹</button>
<button onclick="aiFirst()">AIå…ˆæ‰‹</button>

<script>
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');
const size = 15; // æ£‹ç›˜å¤§å°
const cell = canvas.width / size; // æ¯æ ¼å¤§å°
let board = Array.from({length:size}, ()=>Array(size).fill(0)); // 0:ç©º, 1:ç©å®¶(é»‘), 2:AI(çº¢)
let gameOver = false;
let playerTurn = true; // true: ç©å®¶å›åˆ, false: AIå›åˆ
let currentDepth = 3; // Default search depth, matches "æ™®é€š" radio button value

// --- ä¿®æ”¹å¼€å§‹ï¼šè®¾ç½®åç«¯URLä¸ºæœ¬åœ°åœ°å€ ---
const AI_BACKEND_URL = 'http://127.0.0.1:5000/ai_move'; // æœ¬åœ°å¼€å‘URL
// const AI_BACKEND_URL = '/ai_move'; // Verceléƒ¨ç½²ä½¿ç”¨çš„ç›¸å¯¹è·¯å¾„ (æ³¨é‡Šæ‰)
// --- ä¿®æ”¹ç»“æŸ ---

// --- ç»˜åˆ¶ç›¸å…³ (Keep as is) ---
function drawBoard() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = "#f0d9b5";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.strokeStyle="#333";
  ctx.lineWidth = 1;
  for(let i=0;i<size;i++){
    ctx.beginPath(); ctx.moveTo(cell/2, cell/2 + i*cell); ctx.lineTo(canvas.width - cell/2, cell/2 + i*cell); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(cell/2 + i*cell, cell/2); ctx.lineTo(cell/2 + i*cell, canvas.height - cell/2); ctx.stroke();
  }
    const starPoints = [ [3, 3], [11, 3], [3, 11], [11, 11], [7, 7] ];
    ctx.fillStyle = "#333";
    starPoints.forEach(([x, y]) => { ctx.beginPath(); ctx.arc(cell / 2 + x * cell, cell / 2 + y * cell, cell * 0.1, 0, Math.PI * 2); ctx.fill(); });

  for(let y=0;y<size;y++){
    for(let x=0;x<size;x++){
      if(board[y][x]!==0){
        let color = board[y][x] === 1 ? "black" : "#D80000";
        ctx.beginPath(); ctx.arc(cell/2 + x*cell, cell/2 + y*cell, cell*0.4, 0, Math.PI*2); ctx.fillStyle=color;
        // Simple shadow for depth
        ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
        ctx.shadowBlur = 3;
        ctx.shadowOffsetX = 1;
        ctx.shadowOffsetY = 1;
        ctx.fill();
        ctx.shadowColor = 'transparent'; // Reset shadow
      }
    }
  }
}

// --- æ¸¸æˆé€»è¾‘ (Keep checkWin, isFull) ---
function checkWin(x,y,player){
  if(x<0 || y<0 || x>=size || y>=size || board[y][x] !== player) return false;
  const dirs = [[1,0],[0,1],[1,1],[1,-1]];
  for(const [dx,dy] of dirs){
    let count=1;
    for(let i=1;i<5;i++){ let nx=x+i*dx, ny=y+i*dy; if(nx<0||ny<0||nx>=size||ny>=size || board[ny][nx] !== player) break; count++; }
    for(let i=1;i<5;i++){ let nx=x-i*dx, ny=y-i*dy; if(nx<0||ny<0||nx>=size||ny>=size || board[ny][nx] !== player) break; count++; }
    if(count>=5) return true;
  }
  return false;
}

function isFull(){
  return board.every(row=>row.every(cell=>cell!==0));
}

// --- Event Listener (Modified for AI call) ---
canvas.addEventListener('click',function(e){
  if(gameOver || !playerTurn) return;

  const rect=canvas.getBoundingClientRect();
  let x=Math.floor((e.clientX - rect.left)/cell);
  let y=Math.floor((e.clientY - rect.top)/cell);

  if(x<0||y<0||x>=size||y>=size||board[y][x]!==0) return;

  board[y][x]=1;
  drawBoard();

  if(checkWin(x,y,1)){
    setStatus("æ­å–œä½ èµ¢äº†ï¼ğŸ‰");
    gameOver=true;
    return;
  }
  if(isFull()){
    setStatus("å¹³å±€ï¼ğŸ¤");
    gameOver=true;
    return;
  }

  playerTurn = false;
  // Update status immediately BEFORE calling AI
  setStatus("AIæ€è€ƒä¸­...ğŸ¤”", true); // Add thinking class
  // Call the backend AI - Use setTimeout to allow UI update before potential blocking fetch
  setTimeout(requestAiMove, 50); // Small delay for UI render
});

// --- AI Move Function (Calls Backend) ---
async function requestAiMove() {
    if (gameOver) return;

    console.log("Requesting AI move from backend...");
    try {
        // ä½¿ç”¨ä¸Šé¢å®šä¹‰çš„ AI_BACKEND_URL (å·²ä¿®æ”¹ä¸ºæœ¬åœ°åœ°å€)
        const response = await fetch(AI_BACKEND_URL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ board: board, depth: currentDepth }) // Send current board state and depth
        });

        if (!response.ok) {
            // Handle HTTP errors
            const errorData = await response.json().catch(() => ({})); // Try get JSON error, or empty obj
            console.error(`Backend Error: ${response.status}`, errorData);
            setStatus(`AI é”™è¯¯: ${errorData.error || response.statusText} ğŸ˜­`);
            // Decide game state: end game or allow player retry? Here maybe end it.
            // gameOver = true; // Option 1: End game on error
            playerTurn = true; // Option 2: Give turn back to player? Risky.
            setStatus("å‘ç”Ÿé”™è¯¯ï¼Œè¯·é‡è¯•æˆ–åˆ·æ–°"); // Reset status without thinking indicator
            return;
        }

        const data = await response.json();

        if (data.error) {
             console.error("Backend returned an error:", data.error);
             setStatus(`AI é”™è¯¯: ${data.error} ğŸ˜­`);
             // gameOver = true;
             setStatus("AI å†…éƒ¨é”™è¯¯ï¼Œè¯·é‡è¯•æˆ–åˆ·æ–°"); // Reset status without thinking indicator
             playerTurn = true; // Give turn back
             return;
        }


        if (data.move && typeof data.move.x === 'number' && typeof data.move.y === 'number') {
            const { x, y } = data.move;

             // Double check if the move is valid locally (optional, but good practice)
             if (y < 0 || y >= size || x < 0 || x >= size || board[y][x] !== 0) {
                 console.error(`Backend returned invalid move: (${x}, ${y}). Current board cell: ${board[y]?.[x]}`);
                setStatus("AI è¿”å›äº†æ— æ•ˆçš„ç§»åŠ¨! ğŸ¤¯");
                // gameOver = true; // Probably end game
                setStatus("AI ç§»åŠ¨æ— æ•ˆï¼Œè¯·é‡è¯•æˆ–åˆ·æ–°"); // Reset status without thinking indicator
                playerTurn = true; // Give turn back
                return;
             }

            console.log(`AI move received: (${x}, ${y})`);
            board[y][x] = 2; // 2 represents AI
            drawBoard();

            if (checkWin(x, y, 2)) {
                setStatus("AIèµ¢äº†ï¼ğŸ¤–");
                gameOver = true;
                return;
            }

            if (isFull()) {
                setStatus("å¹³å±€ï¼ğŸ¤");
                gameOver = true;
                return;
            }

            // It's player's turn again
            playerTurn = true;
            setStatus("æ‚¨çš„å›åˆ"); // Remove thinking class

        } else {
            console.error("Invalid response format from backend:", data);
            setStatus("AIå“åº”æ ¼å¼é”™è¯¯! ğŸ˜µ");
            setStatus("AI å“åº”é”™è¯¯ï¼Œè¯·é‡è¯•æˆ–åˆ·æ–°"); // Reset status without thinking indicator
            playerTurn = true; // Give turn back
            // gameOver = true;
        }

    } catch (error) {
        console.error('Network error or failed to fetch AI move:', error);
        setStatus("æ— æ³•è¿æ¥åˆ°AIæœåŠ¡å™¨! ğŸ”Œ");
        // Handle network error - maybe revert turn? Or indicate connection lost
        // playerTurn = true; // Give turn back?
        setStatus("ç½‘ç»œé”™è¯¯ï¼Œè¯·æ£€æŸ¥è¿æ¥æˆ–åˆ·æ–°"); // Reset status without thinking indicator
        playerTurn = true; // Give turn back
    }
}

// --- Control Functions (Modified resetGame, aiFirst calls backend) ---
function setStatus(message, isThinking = false) {
    const statusDiv = document.getElementById('status');
    const textSpan = statusDiv.firstChild; // Get the text node
    textSpan.nodeValue = message; // Update only the text part

    if (isThinking) {
        statusDiv.classList.add('thinking');
    } else {
        statusDiv.classList.remove('thinking');
    }
}

function resetGame(){
  board = Array.from({length:size},()=>Array(size).fill(0));
  gameOver = false;
  playerTurn = true;
  drawBoard();
  setStatus("æ¸¸æˆé‡ç½®ï¼Œæ‚¨çš„å›åˆ");
  // Keep selected difficulty
}

function setDifficulty(level) {
    currentDepth = parseInt(level, 10);
    console.log(`éš¾åº¦è®¾ç½®ä¸º: ${level}, æœç´¢æ·±åº¦: ${currentDepth}`);
    // Reset game when difficulty changes
    resetGame();
    setStatus(`éš¾åº¦å·²åˆ‡æ¢ (${level})ï¼Œæ¸¸æˆé‡ç½®ï¼Œæ‚¨çš„å›åˆ`);
}

function aiFirst() {
    resetGame();
    playerTurn = false;
    setStatus("AIå…ˆæ‰‹ï¼Œæ€è€ƒä¸­...ğŸ¤”", true); // Show thinking indicator
    // Option 1: Let AI calculate the first move via backend (slower first turn)
    setTimeout(requestAiMove, 50);

    // Option 2: AI always plays center first (faster first turn)
    /*
    let centerX = Math.floor(size / 2);
    let centerY = Math.floor(size / 2);
    if (board[centerY][centerX] === 0) {
         board[centerY][centerX] = 2;
         drawBoard();
         playerTurn = true;
         setStatus("æ‚¨çš„å›åˆ");
    } else {
        // Fallback if center somehow taken (shouldn't happen on reset)
         setStatus("AIå…ˆæ‰‹ï¼Œæ€è€ƒä¸­...ğŸ¤”", true);
         setTimeout(requestAiMove, 50);
    }
    */
}

// --- Initial Setup ---
drawBoard(); // Initial draw
// Ensure the default checked difficulty matches currentDepth
document.querySelector(`input[name="difficulty"][value="${currentDepth}"]`).checked = true;
</script>
</body>
</html>
