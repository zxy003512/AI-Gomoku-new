<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<title>ZXYç®—æ³•äº”å­æ£‹</title> <style>
  body { font-family: sans-serif; text-align: center; }
  .canvas-container {
      display: inline-block;
      margin: 10px auto;
  }
  canvas {
      border: 1px solid #333;
      cursor: pointer;
      display: block;
      background-color: #f0d9b5; /* Light wood color */
  }
  #status { margin-top: 10px; font-size: 1.2em; min-height: 1.5em; }
  .controls { margin: 15px 5px; padding: 10px; border: 1px solid #ccc; display: inline-block; border-radius: 5px;}
  .controls div { margin-bottom: 8px; } /* Spacing between input groups */
  .controls label { margin-right: 5px; display: inline-block; min-width: 100px; text-align: right;}
  .controls input[type="number"] { width: 60px; margin-right: 10px; }
  .controls button { padding: 5px 10px; cursor: pointer; margin-left: 10px;}
  .game-buttons button { margin: 5px; padding: 8px 15px; cursor: pointer; }
  .thinking-indicator { display: none; font-style: italic; color: #555; }
  #status.thinking .thinking-indicator { display: inline; }
  #validation-error { color: red; font-size: 0.9em; min-height: 1em; margin-top: 5px;}
</style>
</head>
<body>
<h1>ZXYç®—æ³•äº”å­æ£‹</h1>

<div class="controls">
  <div>
    <label for="depthInput">æœç´¢æ·±åº¦:</label>
    <input type="number" id="depthInput" min="1" max="20" value="2"> <span>(1-20, å»ºè®® â‰¤ 4)</span>
  </div>
  <div>
    <label for="workersInput">å¹¶è¡Œå·¥ä½œå•å…ƒ:</label>
    <input type="number" id="workersInput" min="1" max="200" value="4"> <span>(1-200)</span>
  </div>
  <div>
    <button id="applySettingsBtn" onclick="applySettings()">åº”ç”¨è®¾ç½®</button>
     <span id="validation-error"></span> </div>
</div>


<div class="canvas-container">
    <canvas id="board" width="750" height="750"></canvas>
</div>

<div id="status">æ‚¨çš„å›åˆ<span class="thinking-indicator"> (AI æ€è€ƒä¸­...)</span></div>
<div class="game-buttons"> <button onclick="resetGame()">é‡æ–°å¼€å§‹</button>
  <button onclick="aiFirst()">AI å…ˆæ‰‹</button>
</div>

<script>
const canvas = document.getElementById('board'),
      ctx    = canvas.getContext('2d'),
      N      = 30, // Board size (30x30) - Remains the same
      // ä¿®æ”¹: cell size recalculates based on new canvas size (750/30 = 25)
      cell   = canvas.width / N;

let board = Array.from({ length: N }, () => Array(N).fill(0)), // 0: Empty, 1: Player, 2: AI
    gameOver = false,
    playerTurn = true,
    // --- Initial settings ---
    currentDepth = 2,  // Default AI search depth (recommend low for 30x30)
    currentThreads = 4; // Default number of parallel workers

const API = 'http://127.0.0.1:5000/ai_move'; // Backend API endpoint

// Function to draw the board and pieces (no changes needed, uses 'cell')
function drawBoard() {
  ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas

  // Draw grid lines
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 1;
   // Optimize drawing for thin lines on high DPI? Maybe not needed here.
   // ctx.lineWidth = Math.max(1, 1 / (window.devicePixelRatio || 1));


  for (let i = 0; i < N; i++) {
    const pos = cell / 2 + i * cell;
    // Horizontal lines
    ctx.beginPath();
    ctx.moveTo(cell / 2, pos);
    ctx.lineTo(canvas.width - cell / 2, pos);
    ctx.stroke();
    // Vertical lines
    ctx.beginPath();
    ctx.moveTo(pos, cell / 2);
    ctx.lineTo(pos, canvas.height - cell / 2);
    ctx.stroke();
  }

  // Draw star points (adjusted for 30x30, coordinates are 0-indexed)
   const starPoints = [
      [7, 7], [22, 7], [7, 22], [22, 22], [15, 15],
      [7,15], [22,15], [15,7], [15,22]
      ];
  ctx.fillStyle = '#333';
  starPoints.forEach(p => {
    if (p[0] >= 0 && p[0] < N && p[1] >= 0 && p[1] < N) {
        ctx.beginPath();
        // Make star points slightly smaller relative to the smaller cell size
        ctx.arc(cell / 2 + p[0] * cell, cell / 2 + p[1] * cell, cell * 0.08, 0, 2 * Math.PI);
        ctx.fill();
    }
  });

  // Draw pieces
  for (let y = 0; y < N; y++) {
    for (let x = 0; x < N; x++) {
      if (board[y][x]) {
        ctx.beginPath();
        // Piece radius relative to cell size
        ctx.arc(cell / 2 + x * cell, cell / 2 + y * cell, cell * 0.4, 0, 2 * Math.PI);
        ctx.fillStyle = board[y][x] === 1 ? 'black' : '#D80000'; // Red for AI
        ctx.shadowColor = 'rgba(0,0,0,0.3)'; // Slightly lighter shadow?
        ctx.shadowBlur = 2; ctx.shadowOffsetX = 1; ctx.shadowOffsetY = 1;
        ctx.fill();
        ctx.shadowColor = 'transparent';
      }
    }
  }
}

// Function to check win (no changes needed)
function checkWin(x, y, p) {
  if (x < 0 || y < 0 || x >= N || y >= N || board[y][x] !== p) return false;
  const dirs = [[1, 0], [0, 1], [1, 1], [1, -1]];
  for (let [dx, dy] of dirs) {
    let cnt = 1;
    for(let sign = -1; sign <= 1; sign += 2) { // Check both positive and negative directions
        for (let i = 1; i < 5; i++) {
          let nx = x + i * dx * sign;
          let ny = y + i * dy * sign;
          if (nx < 0 || ny < 0 || nx >= N || ny >= N || board[ny][nx] !== p) break;
          cnt++;
        }
    }
    if (cnt >= 5) return true;
  }
  return false;
}

// Function check draw (no changes needed)
function isFull() {
  return board.every(row => row.every(cell => cell === 0 ? false : true));
}

// Click listener (no changes needed in core logic)
canvas.addEventListener('click', e => {
  if (gameOver || !playerTurn) return;

  let rect = canvas.getBoundingClientRect();
  let scaleX = canvas.width / rect.width;
  let scaleY = canvas.height / rect.height;
  let canvasX = (e.clientX - rect.left) * scaleX;
  let canvasY = (e.clientY - rect.top) * scaleY;
  let x = Math.floor(canvasX / cell);
  let y = Math.floor(canvasY / cell);

  if (x < 0 || y < 0 || x >= N || y >= N || board[y][x] !== 0) return;

  board[y][x] = 1;
  drawBoard();

  if (checkWin(x, y, 1)) {
    setStatus('ä½ èµ¢äº†ï¼ğŸ‰');
    gameOver = true;
    return;
  }
  if (isFull()) {
    setStatus('å¹³å±€ï¼ğŸ¤');
    gameOver = true;
    return;
  }

  playerTurn = false;
  setStatus('AI æ€è€ƒä¸­...ğŸ¤”', true);
  setTimeout(requestAiMove, 50);
});

// Request AI move (no changes needed)
async function requestAiMove() {
  if (gameOver) return;
  await new Promise(resolve => setTimeout(resolve, 20)); // Ensure status update shows

  try {
    console.log(`Requesting AI move: Depth=${currentDepth}, Threads=${currentThreads}`);
    let res = await fetch(API, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ board: board, depth: currentDepth, threads: currentThreads })
    });

    let responseText = await res.text();
    if (!res.ok) {
        console.error("AI Server HTTP Error:", res.status, responseText);
        try { let errorData = JSON.parse(responseText); setStatus(`AI é”™è¯¯: ${errorData.error || `æœåŠ¡å™¨é”™è¯¯ ${res.status}`}`); }
        catch (parseError) { setStatus(`AI é”™è¯¯: æœåŠ¡å™¨å“åº”å¼‚å¸¸ (${res.status})`); }
        playerTurn = true; return;
    }

    let data;
    try { data = JSON.parse(responseText); }
    catch (parseError) {
        console.error("Failed to parse AI response JSON:", responseText);
        setStatus(`AI é”™è¯¯: æ— æ³•è§£ææœåŠ¡å™¨å“åº”`); playerTurn = true; return;
    }

    if (data.error) {
      console.error("AI Logic Error:", data.error);
      setStatus(`AI é”™è¯¯: ${data.error}`); playerTurn = true; return;
    }

    if (data.move && data.move.x !== undefined && data.move.y !== undefined) {
        let { x, y } = data.move;
        console.log("AI move received:", data.move);
        if (x >= 0 && y >= 0 && x < N && y < N && board[y][x] === 0) {
            board[y][x] = 2;
            drawBoard();
            if (checkWin(x, y, 2)) { setStatus('AI èµ¢äº†ï¼ğŸ¤–'); gameOver = true; return; }
            if (isFull()) { setStatus('å¹³å±€ï¼ğŸ¤'); gameOver = true; return; }
            playerTurn = true;
            setStatus('æ‚¨çš„å›åˆ');
        } else {
            console.error("Invalid move received from AI:", data.move, ` Cell value: ${board[y]?.[x] ?? 'OOB'}`);
            setStatus('AI è¿”å›äº†æ— æ•ˆçš„ç§»åŠ¨ï¼'); playerTurn = true;
        }
    } else {
         console.error("Invalid response structure from AI:", data);
         setStatus('AI æœªèƒ½è¿”å›æœ‰æ•ˆç§»åŠ¨æ ¼å¼ï¼'); playerTurn = true;
    }
  } catch (err) {
    console.error("Network or fetch error:", err);
    setStatus('æ— æ³•è¿æ¥åˆ° AI æœåŠ¡å™¨ï¼è¯·æ£€æŸ¥æœåŠ¡å™¨æ˜¯å¦è¿è¡Œã€‚'); playerTurn = true;
  }
}

// Update status message (no changes needed)
function setStatus(msg, thinking = false) {
  const st = document.getElementById('status');
  st.textContent = '';
  st.appendChild(document.createTextNode(msg));

  let thinkingIndicator = st.querySelector('.thinking-indicator');
  if (!thinkingIndicator) {
      thinkingIndicator = document.createElement('span');
      thinkingIndicator.className = 'thinking-indicator';
      thinkingIndicator.textContent = ' (AI æ€è€ƒä¸­...)';
      st.appendChild(thinkingIndicator);
  }
  thinkingIndicator.style.display = thinking ? 'inline' : 'none';
  st.classList.toggle('thinking', thinking); // Use toggle for cleaner class handling
}

// Reset game state (no changes needed)
function resetGame() {
  board = Array.from({ length: N }, () => Array(N).fill(0));
  gameOver = false;
  playerTurn = true;
  drawBoard();
  setStatus('æ¸¸æˆå·²é‡ç½®ï¼Œæ‚¨çš„å›åˆ');
}

// --- NEW: Apply settings from input fields ---
function applySettings() {
    const depthInput = document.getElementById('depthInput');
    const workersInput = document.getElementById('workersInput');
    const errorSpan = document.getElementById('validation-error');
    errorSpan.textContent = ''; // Clear previous errors

    let newDepth = parseInt(depthInput.value, 10);
    let newWorkers = parseInt(workersInput.value, 10);
    let isValid = true;

    // Validate Depth
    if (isNaN(newDepth) || newDepth < 1 || newDepth > 20) {
        errorSpan.textContent += 'æ·±åº¦å¿…é¡»åœ¨ 1 åˆ° 20 ä¹‹é—´ã€‚';
        depthInput.value = currentDepth; // Reset to previous valid value
        isValid = false;
    }

    // Validate Workers
    if (isNaN(newWorkers) || newWorkers < 1 || newWorkers > 200) {
         errorSpan.textContent += (isValid ? '' : ' ') + 'å·¥ä½œå•å…ƒå¿…é¡»åœ¨ 1 åˆ° 200 ä¹‹é—´ã€‚';
         workersInput.value = currentThreads; // Reset to previous valid value
         isValid = false;
    }

    if (isValid) {
        console.log(`åº”ç”¨æ–°è®¾ç½®: æ·±åº¦=${newDepth}, å·¥ä½œå•å…ƒ=${newWorkers}`);
        currentDepth = newDepth;
        currentThreads = newWorkers;
        // It's best to reset the game when settings change significantly
        resetGame();
        setStatus('è®¾ç½®å·²åº”ç”¨ï¼Œå¼€å§‹æ–°æ¸¸æˆ');
    }
}

// AI First move (no changes needed)
function aiFirst() {
  resetGame();
  playerTurn = false;
  setStatus('AI å…ˆæ‰‹...ğŸ¤”', true);
  setTimeout(requestAiMove, 50);
}

// --- Initial setup ---
window.onload = () => {
    // Set initial values in the input boxes to match JS variables
    document.getElementById('depthInput').value = currentDepth;
    document.getElementById('workersInput').value = currentThreads;
    drawBoard(); // Draw the initial empty board (now smaller)
    setStatus('æ¸¸æˆå¼€å§‹ï¼Œæ‚¨çš„å›åˆ');
};

</script>
</body>
</html>