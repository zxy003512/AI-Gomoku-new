<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<title>è‡ªå®šä¹‰éš¾åº¦ & çº¿ç¨‹æ•° AI äº”å­æ£‹</title>
<style>
  body{font-family:sans-serif;text-align:center;}
  canvas{border:1px solid #333; cursor:pointer;}
  #status{margin-top:10px;font-size:1.2em;}
  .controls{margin:10px;}
  .controls label{margin:0 10px;}
  .thinking-indicator{display:none;font-style:italic;color:#555;}
  #status.thinking .thinking-indicator{display:inline;}
</style>
</head>
<body>
<h1>AI äº”å­æ£‹ â€”â€” è‡ªå®šä¹‰éš¾åº¦ & çº¿ç¨‹æ•°</h1>

<div class="controls">
  <label>æœç´¢æ·±åº¦: <input type="range" id="depthRange" min="1" max="12" value="3"
        oninput="setDepth(this.value)" /> <span id="depthVal">3</span></label>
  <label>çº¿ç¨‹æ•°:   <input type="range" id="threadRange" min="1" max="100" value="4"
        oninput="setThreads(this.value)" /> <span id="threadVal">4</span></label>
</div>

<canvas id="board" width="600" height="600"></canvas>
<div id="status">æ‚¨çš„å›åˆ<span class="thinking-indicator"> (AI æ€è€ƒä¸­...)</span></div>
<div class="controls">
  <button onclick="resetGame()">é‡æ–°å¼€å§‹</button>
  <button onclick="aiFirst()">AI å…ˆæ‰‹</button>
</div>

<script>
const canvas = document.getElementById('board'),
      ctx    = canvas.getContext('2d'),
      N      = 15,
      cell   = canvas.width/N;
let board = Array.from({length:N},()=>Array(N).fill(0)),
    gameOver = false,
    playerTurn = true,
    currentDepth = 3,
    currentThreads = 4;

const API = 'http://127.0.0.1:5000/ai_move';

function drawBoard(){
  ctx.clearRect(0,0,600,600);
  ctx.fillStyle='#f0d9b5';
  ctx.fillRect(0,0,600,600);
  ctx.strokeStyle='#333'; ctx.lineWidth=1;
  for(let i=0;i<N;i++){
    ctx.beginPath();
    ctx.moveTo(cell/2,cell/2+i*cell);
    ctx.lineTo(600-cell/2,cell/2+i*cell);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(cell/2+i*cell,cell/2);
    ctx.lineTo(cell/2+i*cell,600-cell/2);
    ctx.stroke();
  }
  // æ˜Ÿä½
  [[3,3],[11,3],[3,11],[11,11],[7,7]].forEach(p=>{
    ctx.beginPath();
    ctx.arc(cell/2+p[0]*cell,cell/2+p[1]*cell,cell*0.1,0,2*Math.PI);
    ctx.fill();
  });
  // æ£‹å­
  for(let y=0;y<N;y++){
    for(let x=0;x<N;x++){
      if(board[y][x]){
        ctx.beginPath();
        ctx.arc(cell/2+x*cell,cell/2+y*cell,cell*0.4,0,2*Math.PI);
        ctx.fillStyle = board[y][x]===1 ? 'black':'#D80000';
        ctx.shadowColor='rgba(0,0,0,0.4)';
        ctx.shadowBlur=3; ctx.shadowOffsetX=1; ctx.shadowOffsetY=1;
        ctx.fill();
        ctx.shadowColor='transparent';
      }
    }
  }
}

function checkWin(x,y,p){
  if(x<0||y<0||x>=N||y>=N||board[y][x]!==p) return false;
  const dirs=[[1,0],[0,1],[1,1],[1,-1]];
  for(let [dx,dy] of dirs){
    let cnt=1;
    for(let i=1;i<5;i++){
      let nx=x+i*dx, ny=y+i*dy;
      if(nx<0||ny<0||nx>=N||ny>=N||board[ny][nx]!==p) break;
      cnt++;
    }
    for(let i=1;i<5;i++){
      let nx=x-i*dx, ny=y-i*dy;
      if(nx<0||ny<0||nx>=N||ny>=N||board[ny][nx]!==p) break;
      cnt++;
    }
    if(cnt>=5) return true;
  }
  return false;
}

function isFull(){ return board.every(r=>r.every(c=>c!==0)); }

canvas.addEventListener('click',e=>{
  if(gameOver||!playerTurn) return;
  let rect=canvas.getBoundingClientRect(),
      x=Math.floor((e.clientX-rect.left)/cell),
      y=Math.floor((e.clientY-rect.top)/cell);
  if(x<0||y<0||x>=N||y>=N||board[y][x]!==0) return;
  board[y][x]=1; drawBoard();
  if(checkWin(x,y,1)){ setStatus('ä½ èµ¢äº†ï¼ğŸ‰'); gameOver=true; return; }
  if(isFull()){ setStatus('å¹³å±€ï¼ğŸ¤'); gameOver=true; return; }
  playerTurn=false;
  setStatus('AI æ€è€ƒä¸­...ğŸ¤”', true);
  setTimeout(requestAiMove,50);
});

async function requestAiMove(){
  if(gameOver) return;
  try{
    let res = await fetch(API,{
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ board, depth:currentDepth, threads:currentThreads })
    });
    let data = await res.json();
    if(data.error){
      setStatus(`AI é”™è¯¯: ${data.error}`); playerTurn=true; return;
    }
    let {x,y}=data.move;
    board[y][x]=2; drawBoard();
    if(checkWin(x,y,2)){ setStatus('AI èµ¢äº†ï¼ğŸ¤–'); gameOver=true; return; }
    if(isFull()){ setStatus('å¹³å±€ï¼ğŸ¤'); gameOver=true; return; }
    playerTurn=true; setStatus('æ‚¨çš„å›åˆ');
  }catch(err){
    console.error(err);
    setStatus('æ— æ³•è¿æ¥åˆ° AI æœåŠ¡å™¨ï¼');
    playerTurn=true;
  }
}

function setStatus(msg, thinking=false){
  const st = document.getElementById('status');
  st.textContent = msg;
  if(thinking) st.classList.add('thinking');
  else        st.classList.remove('thinking');
}

function resetGame(){
  board = Array.from({length:N},()=>Array(N).fill(0));
  gameOver=false; playerTurn=true;
  drawBoard(); setStatus('æ¸¸æˆå·²é‡ç½®ï¼Œæ‚¨çš„å›åˆ');
}
function setDepth(v){
  currentDepth = +v;
  document.getElementById('depthVal').textContent=v;
  resetGame();
}
function setThreads(v){
  currentThreads = +v;
  document.getElementById('threadVal').textContent=v;
  // çº¿ç¨‹æ”¹åŠ¨æ— éœ€é‡ç½®æ£‹å±€ï¼Œå¯ä»¥ä¸è°ƒç”¨ resetGame()
}

function aiFirst(){
  resetGame();
  playerTurn=false;
  setStatus('AI å…ˆæ‰‹...ğŸ¤”',true);
  setTimeout(requestAiMove,50);
}

// åˆå§‹ç”»é¢
drawBoard();
document.getElementById('depthVal').textContent   = currentDepth;
document.getElementById('threadVal').textContent  = currentThreads;
</script>
</body>
</html>
